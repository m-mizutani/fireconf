// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/m-mizutani/fireconf/pkg/domain/interfaces"
	"sync"
)

// Ensure, that FirestoreClientMock does implement interfaces.FirestoreClient.
// If this is not the case, regenerate this file with moq.
var _ interfaces.FirestoreClient = &FirestoreClientMock{}

// FirestoreClientMock is a mock implementation of interfaces.FirestoreClient.
//
//	func TestSomethingThatUsesFirestoreClient(t *testing.T) {
//
//		// make and configure a mocked interfaces.FirestoreClient
//		mockedFirestoreClient := &FirestoreClientMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			CollectionExistsFunc: func(ctx context.Context, collectionID string) (bool, error) {
//				panic("mock out the CollectionExists method")
//			},
//			CreateCollectionFunc: func(ctx context.Context, collectionID string) error {
//				panic("mock out the CreateCollection method")
//			},
//			CreateIndexFunc: func(ctx context.Context, collectionID string, index interfaces.FirestoreIndex) (interface{}, error) {
//				panic("mock out the CreateIndex method")
//			},
//			DeleteIndexFunc: func(ctx context.Context, indexName string) (interface{}, error) {
//				panic("mock out the DeleteIndex method")
//			},
//			DisableTTLPolicyFunc: func(ctx context.Context, collectionID string) (interface{}, error) {
//				panic("mock out the DisableTTLPolicy method")
//			},
//			EnableTTLPolicyFunc: func(ctx context.Context, collectionID string, fieldName string) (interface{}, error) {
//				panic("mock out the EnableTTLPolicy method")
//			},
//			GetTTLPolicyFunc: func(ctx context.Context, collectionID string, fieldName string) (*interfaces.FirestoreTTL, error) {
//				panic("mock out the GetTTLPolicy method")
//			},
//			ListCollectionsFunc: func(ctx context.Context) ([]string, error) {
//				panic("mock out the ListCollections method")
//			},
//			ListIndexesFunc: func(ctx context.Context, collectionID string) ([]interfaces.FirestoreIndex, error) {
//				panic("mock out the ListIndexes method")
//			},
//			WaitForOperationFunc: func(ctx context.Context, operation interface{}) error {
//				panic("mock out the WaitForOperation method")
//			},
//		}
//
//		// use mockedFirestoreClient in code that requires interfaces.FirestoreClient
//		// and then make assertions.
//
//	}
type FirestoreClientMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// CollectionExistsFunc mocks the CollectionExists method.
	CollectionExistsFunc func(ctx context.Context, collectionID string) (bool, error)

	// CreateCollectionFunc mocks the CreateCollection method.
	CreateCollectionFunc func(ctx context.Context, collectionID string) error

	// CreateIndexFunc mocks the CreateIndex method.
	CreateIndexFunc func(ctx context.Context, collectionID string, index interfaces.FirestoreIndex) (interface{}, error)

	// DeleteIndexFunc mocks the DeleteIndex method.
	DeleteIndexFunc func(ctx context.Context, indexName string) (interface{}, error)

	// DisableTTLPolicyFunc mocks the DisableTTLPolicy method.
	DisableTTLPolicyFunc func(ctx context.Context, collectionID string) (interface{}, error)

	// EnableTTLPolicyFunc mocks the EnableTTLPolicy method.
	EnableTTLPolicyFunc func(ctx context.Context, collectionID string, fieldName string) (interface{}, error)

	// GetTTLPolicyFunc mocks the GetTTLPolicy method.
	GetTTLPolicyFunc func(ctx context.Context, collectionID string, fieldName string) (*interfaces.FirestoreTTL, error)

	// ListCollectionsFunc mocks the ListCollections method.
	ListCollectionsFunc func(ctx context.Context) ([]string, error)

	// ListIndexesFunc mocks the ListIndexes method.
	ListIndexesFunc func(ctx context.Context, collectionID string) ([]interfaces.FirestoreIndex, error)

	// WaitForOperationFunc mocks the WaitForOperation method.
	WaitForOperationFunc func(ctx context.Context, operation interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// CollectionExists holds details about calls to the CollectionExists method.
		CollectionExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CollectionID is the collectionID argument value.
			CollectionID string
		}
		// CreateCollection holds details about calls to the CreateCollection method.
		CreateCollection []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CollectionID is the collectionID argument value.
			CollectionID string
		}
		// CreateIndex holds details about calls to the CreateIndex method.
		CreateIndex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CollectionID is the collectionID argument value.
			CollectionID string
			// Index is the index argument value.
			Index interfaces.FirestoreIndex
		}
		// DeleteIndex holds details about calls to the DeleteIndex method.
		DeleteIndex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IndexName is the indexName argument value.
			IndexName string
		}
		// DisableTTLPolicy holds details about calls to the DisableTTLPolicy method.
		DisableTTLPolicy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CollectionID is the collectionID argument value.
			CollectionID string
		}
		// EnableTTLPolicy holds details about calls to the EnableTTLPolicy method.
		EnableTTLPolicy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CollectionID is the collectionID argument value.
			CollectionID string
			// FieldName is the fieldName argument value.
			FieldName string
		}
		// GetTTLPolicy holds details about calls to the GetTTLPolicy method.
		GetTTLPolicy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CollectionID is the collectionID argument value.
			CollectionID string
			// FieldName is the fieldName argument value.
			FieldName string
		}
		// ListCollections holds details about calls to the ListCollections method.
		ListCollections []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListIndexes holds details about calls to the ListIndexes method.
		ListIndexes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CollectionID is the collectionID argument value.
			CollectionID string
		}
		// WaitForOperation holds details about calls to the WaitForOperation method.
		WaitForOperation []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Operation is the operation argument value.
			Operation interface{}
		}
	}
	lockClose            sync.RWMutex
	lockCollectionExists sync.RWMutex
	lockCreateCollection sync.RWMutex
	lockCreateIndex      sync.RWMutex
	lockDeleteIndex      sync.RWMutex
	lockDisableTTLPolicy sync.RWMutex
	lockEnableTTLPolicy  sync.RWMutex
	lockGetTTLPolicy     sync.RWMutex
	lockListCollections  sync.RWMutex
	lockListIndexes      sync.RWMutex
	lockWaitForOperation sync.RWMutex
}

// Close calls CloseFunc.
func (mock *FirestoreClientMock) Close() error {
	if mock.CloseFunc == nil {
		panic("FirestoreClientMock.CloseFunc: method is nil but FirestoreClient.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedFirestoreClient.CloseCalls())
func (mock *FirestoreClientMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// CollectionExists calls CollectionExistsFunc.
func (mock *FirestoreClientMock) CollectionExists(ctx context.Context, collectionID string) (bool, error) {
	if mock.CollectionExistsFunc == nil {
		panic("FirestoreClientMock.CollectionExistsFunc: method is nil but FirestoreClient.CollectionExists was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		CollectionID string
	}{
		Ctx:          ctx,
		CollectionID: collectionID,
	}
	mock.lockCollectionExists.Lock()
	mock.calls.CollectionExists = append(mock.calls.CollectionExists, callInfo)
	mock.lockCollectionExists.Unlock()
	return mock.CollectionExistsFunc(ctx, collectionID)
}

// CollectionExistsCalls gets all the calls that were made to CollectionExists.
// Check the length with:
//
//	len(mockedFirestoreClient.CollectionExistsCalls())
func (mock *FirestoreClientMock) CollectionExistsCalls() []struct {
	Ctx          context.Context
	CollectionID string
} {
	var calls []struct {
		Ctx          context.Context
		CollectionID string
	}
	mock.lockCollectionExists.RLock()
	calls = mock.calls.CollectionExists
	mock.lockCollectionExists.RUnlock()
	return calls
}

// CreateCollection calls CreateCollectionFunc.
func (mock *FirestoreClientMock) CreateCollection(ctx context.Context, collectionID string) error {
	if mock.CreateCollectionFunc == nil {
		panic("FirestoreClientMock.CreateCollectionFunc: method is nil but FirestoreClient.CreateCollection was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		CollectionID string
	}{
		Ctx:          ctx,
		CollectionID: collectionID,
	}
	mock.lockCreateCollection.Lock()
	mock.calls.CreateCollection = append(mock.calls.CreateCollection, callInfo)
	mock.lockCreateCollection.Unlock()
	return mock.CreateCollectionFunc(ctx, collectionID)
}

// CreateCollectionCalls gets all the calls that were made to CreateCollection.
// Check the length with:
//
//	len(mockedFirestoreClient.CreateCollectionCalls())
func (mock *FirestoreClientMock) CreateCollectionCalls() []struct {
	Ctx          context.Context
	CollectionID string
} {
	var calls []struct {
		Ctx          context.Context
		CollectionID string
	}
	mock.lockCreateCollection.RLock()
	calls = mock.calls.CreateCollection
	mock.lockCreateCollection.RUnlock()
	return calls
}

// CreateIndex calls CreateIndexFunc.
func (mock *FirestoreClientMock) CreateIndex(ctx context.Context, collectionID string, index interfaces.FirestoreIndex) (interface{}, error) {
	if mock.CreateIndexFunc == nil {
		panic("FirestoreClientMock.CreateIndexFunc: method is nil but FirestoreClient.CreateIndex was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		CollectionID string
		Index        interfaces.FirestoreIndex
	}{
		Ctx:          ctx,
		CollectionID: collectionID,
		Index:        index,
	}
	mock.lockCreateIndex.Lock()
	mock.calls.CreateIndex = append(mock.calls.CreateIndex, callInfo)
	mock.lockCreateIndex.Unlock()
	return mock.CreateIndexFunc(ctx, collectionID, index)
}

// CreateIndexCalls gets all the calls that were made to CreateIndex.
// Check the length with:
//
//	len(mockedFirestoreClient.CreateIndexCalls())
func (mock *FirestoreClientMock) CreateIndexCalls() []struct {
	Ctx          context.Context
	CollectionID string
	Index        interfaces.FirestoreIndex
} {
	var calls []struct {
		Ctx          context.Context
		CollectionID string
		Index        interfaces.FirestoreIndex
	}
	mock.lockCreateIndex.RLock()
	calls = mock.calls.CreateIndex
	mock.lockCreateIndex.RUnlock()
	return calls
}

// DeleteIndex calls DeleteIndexFunc.
func (mock *FirestoreClientMock) DeleteIndex(ctx context.Context, indexName string) (interface{}, error) {
	if mock.DeleteIndexFunc == nil {
		panic("FirestoreClientMock.DeleteIndexFunc: method is nil but FirestoreClient.DeleteIndex was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		IndexName string
	}{
		Ctx:       ctx,
		IndexName: indexName,
	}
	mock.lockDeleteIndex.Lock()
	mock.calls.DeleteIndex = append(mock.calls.DeleteIndex, callInfo)
	mock.lockDeleteIndex.Unlock()
	return mock.DeleteIndexFunc(ctx, indexName)
}

// DeleteIndexCalls gets all the calls that were made to DeleteIndex.
// Check the length with:
//
//	len(mockedFirestoreClient.DeleteIndexCalls())
func (mock *FirestoreClientMock) DeleteIndexCalls() []struct {
	Ctx       context.Context
	IndexName string
} {
	var calls []struct {
		Ctx       context.Context
		IndexName string
	}
	mock.lockDeleteIndex.RLock()
	calls = mock.calls.DeleteIndex
	mock.lockDeleteIndex.RUnlock()
	return calls
}

// DisableTTLPolicy calls DisableTTLPolicyFunc.
func (mock *FirestoreClientMock) DisableTTLPolicy(ctx context.Context, collectionID string) (interface{}, error) {
	if mock.DisableTTLPolicyFunc == nil {
		panic("FirestoreClientMock.DisableTTLPolicyFunc: method is nil but FirestoreClient.DisableTTLPolicy was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		CollectionID string
	}{
		Ctx:          ctx,
		CollectionID: collectionID,
	}
	mock.lockDisableTTLPolicy.Lock()
	mock.calls.DisableTTLPolicy = append(mock.calls.DisableTTLPolicy, callInfo)
	mock.lockDisableTTLPolicy.Unlock()
	return mock.DisableTTLPolicyFunc(ctx, collectionID)
}

// DisableTTLPolicyCalls gets all the calls that were made to DisableTTLPolicy.
// Check the length with:
//
//	len(mockedFirestoreClient.DisableTTLPolicyCalls())
func (mock *FirestoreClientMock) DisableTTLPolicyCalls() []struct {
	Ctx          context.Context
	CollectionID string
} {
	var calls []struct {
		Ctx          context.Context
		CollectionID string
	}
	mock.lockDisableTTLPolicy.RLock()
	calls = mock.calls.DisableTTLPolicy
	mock.lockDisableTTLPolicy.RUnlock()
	return calls
}

// EnableTTLPolicy calls EnableTTLPolicyFunc.
func (mock *FirestoreClientMock) EnableTTLPolicy(ctx context.Context, collectionID string, fieldName string) (interface{}, error) {
	if mock.EnableTTLPolicyFunc == nil {
		panic("FirestoreClientMock.EnableTTLPolicyFunc: method is nil but FirestoreClient.EnableTTLPolicy was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		CollectionID string
		FieldName    string
	}{
		Ctx:          ctx,
		CollectionID: collectionID,
		FieldName:    fieldName,
	}
	mock.lockEnableTTLPolicy.Lock()
	mock.calls.EnableTTLPolicy = append(mock.calls.EnableTTLPolicy, callInfo)
	mock.lockEnableTTLPolicy.Unlock()
	return mock.EnableTTLPolicyFunc(ctx, collectionID, fieldName)
}

// EnableTTLPolicyCalls gets all the calls that were made to EnableTTLPolicy.
// Check the length with:
//
//	len(mockedFirestoreClient.EnableTTLPolicyCalls())
func (mock *FirestoreClientMock) EnableTTLPolicyCalls() []struct {
	Ctx          context.Context
	CollectionID string
	FieldName    string
} {
	var calls []struct {
		Ctx          context.Context
		CollectionID string
		FieldName    string
	}
	mock.lockEnableTTLPolicy.RLock()
	calls = mock.calls.EnableTTLPolicy
	mock.lockEnableTTLPolicy.RUnlock()
	return calls
}

// GetTTLPolicy calls GetTTLPolicyFunc.
func (mock *FirestoreClientMock) GetTTLPolicy(ctx context.Context, collectionID string, fieldName string) (*interfaces.FirestoreTTL, error) {
	if mock.GetTTLPolicyFunc == nil {
		panic("FirestoreClientMock.GetTTLPolicyFunc: method is nil but FirestoreClient.GetTTLPolicy was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		CollectionID string
		FieldName    string
	}{
		Ctx:          ctx,
		CollectionID: collectionID,
		FieldName:    fieldName,
	}
	mock.lockGetTTLPolicy.Lock()
	mock.calls.GetTTLPolicy = append(mock.calls.GetTTLPolicy, callInfo)
	mock.lockGetTTLPolicy.Unlock()
	return mock.GetTTLPolicyFunc(ctx, collectionID, fieldName)
}

// GetTTLPolicyCalls gets all the calls that were made to GetTTLPolicy.
// Check the length with:
//
//	len(mockedFirestoreClient.GetTTLPolicyCalls())
func (mock *FirestoreClientMock) GetTTLPolicyCalls() []struct {
	Ctx          context.Context
	CollectionID string
	FieldName    string
} {
	var calls []struct {
		Ctx          context.Context
		CollectionID string
		FieldName    string
	}
	mock.lockGetTTLPolicy.RLock()
	calls = mock.calls.GetTTLPolicy
	mock.lockGetTTLPolicy.RUnlock()
	return calls
}

// ListCollections calls ListCollectionsFunc.
func (mock *FirestoreClientMock) ListCollections(ctx context.Context) ([]string, error) {
	if mock.ListCollectionsFunc == nil {
		panic("FirestoreClientMock.ListCollectionsFunc: method is nil but FirestoreClient.ListCollections was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListCollections.Lock()
	mock.calls.ListCollections = append(mock.calls.ListCollections, callInfo)
	mock.lockListCollections.Unlock()
	return mock.ListCollectionsFunc(ctx)
}

// ListCollectionsCalls gets all the calls that were made to ListCollections.
// Check the length with:
//
//	len(mockedFirestoreClient.ListCollectionsCalls())
func (mock *FirestoreClientMock) ListCollectionsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListCollections.RLock()
	calls = mock.calls.ListCollections
	mock.lockListCollections.RUnlock()
	return calls
}

// ListIndexes calls ListIndexesFunc.
func (mock *FirestoreClientMock) ListIndexes(ctx context.Context, collectionID string) ([]interfaces.FirestoreIndex, error) {
	if mock.ListIndexesFunc == nil {
		panic("FirestoreClientMock.ListIndexesFunc: method is nil but FirestoreClient.ListIndexes was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		CollectionID string
	}{
		Ctx:          ctx,
		CollectionID: collectionID,
	}
	mock.lockListIndexes.Lock()
	mock.calls.ListIndexes = append(mock.calls.ListIndexes, callInfo)
	mock.lockListIndexes.Unlock()
	return mock.ListIndexesFunc(ctx, collectionID)
}

// ListIndexesCalls gets all the calls that were made to ListIndexes.
// Check the length with:
//
//	len(mockedFirestoreClient.ListIndexesCalls())
func (mock *FirestoreClientMock) ListIndexesCalls() []struct {
	Ctx          context.Context
	CollectionID string
} {
	var calls []struct {
		Ctx          context.Context
		CollectionID string
	}
	mock.lockListIndexes.RLock()
	calls = mock.calls.ListIndexes
	mock.lockListIndexes.RUnlock()
	return calls
}

// WaitForOperation calls WaitForOperationFunc.
func (mock *FirestoreClientMock) WaitForOperation(ctx context.Context, operation interface{}) error {
	if mock.WaitForOperationFunc == nil {
		panic("FirestoreClientMock.WaitForOperationFunc: method is nil but FirestoreClient.WaitForOperation was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Operation interface{}
	}{
		Ctx:       ctx,
		Operation: operation,
	}
	mock.lockWaitForOperation.Lock()
	mock.calls.WaitForOperation = append(mock.calls.WaitForOperation, callInfo)
	mock.lockWaitForOperation.Unlock()
	return mock.WaitForOperationFunc(ctx, operation)
}

// WaitForOperationCalls gets all the calls that were made to WaitForOperation.
// Check the length with:
//
//	len(mockedFirestoreClient.WaitForOperationCalls())
func (mock *FirestoreClientMock) WaitForOperationCalls() []struct {
	Ctx       context.Context
	Operation interface{}
} {
	var calls []struct {
		Ctx       context.Context
		Operation interface{}
	}
	mock.lockWaitForOperation.RLock()
	calls = mock.calls.WaitForOperation
	mock.lockWaitForOperation.RUnlock()
	return calls
}
